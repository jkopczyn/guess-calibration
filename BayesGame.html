<html>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<!-- 
First we want to decide on a payoff function P(a,x) to indicate the loss incurred from action a when outcome x is observed where:
a \in [0,1], x \in {0,1}
p=argsup_a p*P(a,1)+(1-p)*P(a,0)
The meaning of this latter property is that if Pr(X=1)=p is the true probability of "heads" then the choice of a that maximizes the expected payout is a=p.
One conventional choice is: P(a,x)=log(a)*x+log(1-a)*(1-x), which correponds to the log-likelihood of x under a Bernoulli(a) model (or negate it and call it a loss and talk about entropy and such)
The expected payout if p is true is, p*log(a)+(1-p)*log(1-a), and d/da of this is: p/a-(1-p)/(1-a)=(p-a)/(a*(1-a)) (for a \ne 0,1)
From this and checking the special cases, we confirm that it, or it plus any finite constant, obeys our argsup property.
[Of course, the same thing would work for multiple choice via multinomial log-likelihood.]

So we can make a Bayes game where there's a certain event about to happen, x=1 or x=0, and we ask the player to move a slider, which moves a via, say, a=logistic(slider scaled to [-5,5]),
but we just show them that they'll win par+L(a,1) if x=1 happens and par+L(a,0) if x=0 happens and let them choose which payouts they want. In this way we'll obtain their probabilities about x
and we can check if they're callibrated.

So where to get these "future" X's?
One way would be to generate them from facts about the world, e.g. did Microsoft stock go up today (x=1) or down (x=0)? 
  If you asked them about future events and checked them later, it'd be a fair way to score prognosticators (though beware the variance of the score if they're guessing too close to 0,1)
  The absolute score wouldn't mean too much (sure you could measure it in bits, etc.) but the relative score b/w players is meaningful. I guess you could set a par value by taking
  the prediction of some consistently available pundit, adjusting their 0/1 prediction to have favorable choices of a_0, a_1, and calling the negative of that score par.
Or one could take basic quantitative facts, like, y=the population of Europe, and generate questions like, say, "Is the population of Europe within (delta*y) of (gamma*y) or not?" where gamma is a random log-normal with some parameters mu and sigma and delta=0.1.
Or one could simulate:
 One could check simulate X randomly, and check if they choose a suitably, when they know the generative model for X.
 One could simulate X_1, X_2, ... iid Bernoulli(p) (with or without a clue for p) and check that their choices of a converge suitably to p.
 One could simulate p~F and then conditionally simulate X_1, X_2, ... iid Bernoulli(p) (i.e. simulate the X_i's according to some exchangable process). This generalizes the previous -- they could know more or less about F a priori. (One extreme: F puts mass 1 on 1/3. Another: a point is picked uniformly from the right triangle formed by the coordinate axes and the line y=1-x, the value of this point on the x-axis is the probability p used for all subsequent draws. Another p~Beta(3,8) but don't tell them)
 One could simulate F from G, some distribution on distributions on [0,1], and (conditionally) simulate p_i's iid from F and (conditionally) simulate X_{i,j} iid Bernoulli(p_i). Then show them various X_{i,j}'s and see how they update all the a_{i,j}'s as they go. You could tell them more or less about G.
 And on and on... G could be random with hyperparameters, or i could have more structure (e.g. in a lattice or a graph or manifold or ...) and the p_i's could obeys a suitable random process on the space of i's.
What about time series? E.g. we could make a simulation in which P(X_n=1 | past) depends only on X_{n-1} or maybe on some part of the past plus auxilliary variables Y_{n-1} that they get to observe before they make their guess. One could use a stock market model for this.

Maybe the "right triangle" version of the game, where I don't tell them, but let them play multiple times (i.e. a fresh p each time) and see if they adapt their play style to the truth about F or not.
Different choices for F could be different levels (i.e. explain the context is different), so they can learn different biases for the different contexts.

-->
<style type="text/css">
.hot {color:#F0F}
.cool {color:#080}
::-webkit-scrollbar {
    -webkit-appearance: none;
    width: 7px;
}
::-webkit-scrollbar-thumb {
    border-radius: 4px;
    background-color: rgba(0,0,0,.5);
    -webkit-box-shadow: 0 0 1px rgba(255,255,255,.5);
}

</style>
<div id="controls">
<form id="controls_form">
<div id="log" style="width:621px;height:200px;overflow-y:scroll;border:1px solid black;padding:2px;resize:both;">
</div>
<br>
<i>Bet on the outcome using the slider to control the payouts.</i><br>
<span style="padding-right:350px">Payout on <span class="hot"><span name="tails"></span>: <span id="payoff0"></span></span></span>
Payout on <span class="hot"><span name="heads"></span>: <span id="payoff1"></span></span><br>
<!--I'm guessing slider radius is 10px and trying to account for how this affects the actual pixel coords. of the slider; something's slightly off below.-->
<input type="range" id="slider1" min="0" max="600" style="width:621; margin:0px;"> <!-- make wider than max by 2*sliderradius+1 -->
<input type="submit" value="Bet"><br>
<div style="margin-left:10px;margin-right:10px"> <!-- pad on left and right by slider radius -->
<canvas id="pbar" width="601" height="40"></canvas><!--width=max+1 so pixels run 0..max -->
</div><br> 
</form>
(These payouts maximize your expected return if you think <span class="hot">p=<span id="a"></span></span> is the probability of <span name="heads"></span>.)<br>
<br>
Current score: <span id="score" class="cool"></span> after <span id="plays" class="cool"></span> plays, for an average score per play of <span id="score_per_play" class="cool"></span>.<br>
<br>
<!--You're playing "<span id="game_title"></span>".-->
Want to play a different game? <select id="game_selector"></select><br>
</div>
<script>
BG={uscale:6, pbarmax:600};
BG.draw_pscale=function() {
  var canvas=$("#pbar")[0];
  BG.pbar=canvas.getContext("2d");
  BG.pbar.clearRect(0, 0, canvas.width, canvas.height);
  BG.pbar.font = "10px sans-serif";
  BG.pbar.textBaseline = "top";
  BG.pbar.textAlign = "center";
  var pv=[0.01,0.05,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,0.95,0.99];
  for (var pi in pv) {
    var p=pv[pi];
    var pu=-Math.log(1/p-1);
    var px=(pu/BG.uscale+1)/2*(BG.pbarmax);
    BG.pbar.fillRect(px,0,1,10);
    BG.pbar.fillText(p.toFixed(2), px ,10+10*(pi%3));
  };
}

BG.do_refresh=function() {
  BG.draw_pscale();
  var s=$("#slider1")[0];
  var u=(2*s.value/(BG.pbarmax)-1)*BG.uscale;
  var a=1/(1+Math.exp(-u));
  BG.a=a;
  var par1=1/Math.log(2);
  var par0=1.0;
  var payoff0=par0+par1*Math.log(1-a);
  var payoff1=par0+par1*Math.log(a);
  BG.payoff=[payoff0, payoff1];
  $("#payoff0").html(payoff0.toFixed(3));
  $("#payoff1").html(payoff1.toFixed(3));
  $("#a").html(a.toFixed(3));
  $("[name='heads']").html(BG.labels[1]);
  $("[name='tails']").html(BG.labels[0]);
  $("#score").html(BG.score.toFixed(3));
  $("#plays").html(BG.plays);
  $("#score_per_play").html((BG.score/BG.plays).toFixed(3));
  $("#game_title").html(BG.title);
  BG.pbar.fillStyle="#F0F";
  BG.pbar.fillRect(s.value,0,1,10);
  BG.pbar.fillStyle="#000";
}

BG.describeCoin=function(p) {
  var coindesc;
  if (p===0.5) coindesc="fair coin";
  else coindesc="p="+p.toFixed(2)+" coin";
  return(coindesc);
}

BG.CoinProcess=function(pheads) {
  this.pheads=pheads;
}
BG.CoinProcess.prototype.title=function(){return("Predict a "+BG.describeCoin(this.pheads))};
BG.CoinProcess.prototype.labels=function(){return(["Tails","Heads"])};
BG.CoinProcess.prototype.initialize=function(){return({html:"",state:{}})};
BG.CoinProcess.prototype.draw=function(state){
  var coindesc=BG.describeCoin(this.pheads);
  var result={html: "I'm about to flip a "+coindesc+". Will I get heads?", state:state};
  result.outcome=(Math.random()<=this.pheads)+0;
  return(result);
};

BG.duplicateObject=function(obj) { // for object literals; shallow copy
  return($.extend(true,{},obj));
}
BG.extendObject=function(defaults,override) {
  return($.extend(BG.duplicateObject(defaults),override));
}
BG.MaskedProcess=function(title,game,options) {
  this.game=game;
  this.mytitle=title;
  var defaults={labels:["No","Yes"],initialmessage:"I'm a mysterious process.", message:"Will I say yes this time?"};
  options=BG.extendObject(defaults,options);
  this.options=options;
}
BG.MaskedProcess.prototype.title=function(){return(this.mytitle);}
BG.MaskedProcess.prototype.labels=function(){return(this.options.labels);}
BG.MaskedProcess.prototype.initialize=function(){
  var i1=this.game.initialize();
  return({html:this.options.initialmessage,state:i1.state});
}
BG.MaskedProcess.prototype.draw=function(state){
  var d1=this.game.draw(state);
  var result={html:this.options.message, state:d1.state, outcome:d1.outcome};
  return(result);
}
  
BG.plays=0; 
BG.games=[new BG.CoinProcess(0.5),new BG.CoinProcess(0.9), new BG.MaskedProcess('Mystery Game 1',new BG.CoinProcess(0.621711006318219),{})];
BG.start_game=function(gameix) {
  if (BG.plays>0) {
    BG.logEvent('<span class="hot">Final score:</span> <span class="cool">'+BG.score.toFixed(3)+
       '</span> after <span class="cool">'+BG.plays+'</span> plays, for an average score per play of <span class="cool">'+
       (BG.score/BG.plays).toFixed(3)+'</span>.');

    }
  var game=BG.games[gameix];
  $("#game_selector")[0].value=gameix;
  BG.score=0;
  BG.plays=0;
  BG.game=game;
  BG.title=game.title();
  BG.logEvent("Starting game: <span class='hot'>"+BG.title+"</span>");
  BG.labels=game.labels();

  var init=BG.game.initialize();
  BG.game_state=init.state;
  BG.logEvent(init.html);
  BG.draw=BG.game.draw(BG.game_state);
  BG.game_state=BG.draw.state;
  BG.logEvent(BG.draw.html);

  BG.do_refresh();
};

BG.handle_submit=function(event) {
  var payoff=BG.payoff[BG.draw.outcome];
  var msg1="You bet as if p="+BG.a.toFixed(3)+" and the outcome was "+BG.labels[BG.draw.outcome]+".";
  var msg2;
  if (payoff>=0) msg2="You gained "+payoff.toFixed(3)+" points."
  else           msg2="You lost "+(-payoff).toFixed(3)+" points."
  BG.score+=payoff;
  BG.plays+=1;
  BG.logEvent("<span style='color:#55F'>"+msg1+" "+msg2+"</span>")
  BG.draw=BG.game.draw(BG.game_state);
  BG.game_state=BG.draw.state;
  var current_score={score: BG.score, plays: BG.plays, avgscore: BG.score/BG.plays};
  if (BG.plays===1) { // create a game_scores object for this session
    if (BG.game_scores[BG.title] === undefined) BG.game_scores[BG.title]=[];
    BG.game_scores[BG.title]=BG.game_scores[BG.title].concat([current_score]);
    }
  else {
    BG.game_scores[BG.title]=BG.game_scores[BG.title].slice(0,-1).concat([current_score]);
    }
  sessionStorage.setItem('game_scores',JSON.stringify(BG.game_scores));
  BG.logEvent(BG.draw.html);
  BG.do_refresh();
}

BG.logEvent=function(h) {
 var l=$("#log")
 l.append(h+"<br>");
 l.scrollTop(l[0].scrollHeight);
}

BG.setup=function() {
  var gs=sessionStorage.getItem('game_scores');
  //sessionStorage.setItem('game_scores','{}') // use this if it gets corrupted
  //JSON.stringify(BG.game_scores,undefined,2) // use this to see the status
  if (gs === null) {
    gs={};
    sessionStorage.setItem('game_scores',JSON.stringify(gs))
    } else gs=JSON.parse(gs);
  BG.game_scores=gs;
  $("#slider1").change(function(e){BG.do_refresh();})
  $("#controls_form").submit(function( event ) {
    BG.handle_submit(event);
    event.preventDefault();
    });
  var selectopts="";
  for (var gameix in BG.games) {
    var game=BG.games[gameix];
    var gt=game.title();
    selectopts+="<option value='"+gameix+"'>"+gt+"</option>"
    }
  $("#game_selector").html(selectopts);
  $("#game_selector").change(function(e){
    //console.log(e);console.log(this);
    var gameix=$("#game_selector")[0].value;
    BG.start_game(gameix);
    });
  // buggy. Weirdness on Firefox.
  //$("#pbar").mousemove(BG.pbar_mouse);
  //$("#pbar").mousedown(BG.pbar_mouse);
}

BG.pbar_mouse=function(e){
  if (e.which) {$("#slider1")[0].value=e.offsetX;BG.do_refresh();}
}

BG.setup();
BG.start_game(1);

</script>
</html>
